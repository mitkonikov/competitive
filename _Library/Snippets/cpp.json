{
	"main": {
		"prefix": "main",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define endl '\\n'",
			"",
			"using namespace std;",
			"",
			"int main() {",
			"\t${1://code}",
			"\tcout << flush;",
			"\treturn 0;",
			"}"
		],
		"description": "Empty template"
	},
	"ttmain": {
		"prefix": "ttmain",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define endl '\\n'",
			"",
			"using namespace std;",
			"",
			"void testCase() {",
			"\t${1://code}",
			"}",
			"",
			"int main() {",
			"\tint t;",
			"\tcin >> t;",
			"",
			"\twhile (t--) {",
			"\t\ttestCase();",
			"\t}",
			"",
			"\tcout << flush;",
			"\treturn 0;",
			"}"
		],
		"description": "Empty template with test cases"
	},
	"gcd": {
		"prefix": "gcd",
		"body": [
			"template<typename T>\r",
			"T gcd(T a, T b) {\r",
			"    return (a == 0) ? b : gcd(b % a, a);\r",
			"}"
		],
		"description": "GCD template"
	},
	"sort": {
		"prefix": "tsort",
		"body": "sort($0.begin(), $0.end());",
		"description": "fast sort template"
	},
	"tprintvec": {
		"prefix": "tprintvec",
		"body": [
			"template<typename T>\r",
			"void printVec(vector<T> vec) {\r",
			"    for (int i = 0; i < vec.size(); i++) {\r",
			"        cout << vec[i] << \" \";\r",
			"    }\r",
			"    cout << endl;\r",
			"}"
		],
		"description": "Print Template Vector"
	},
	"printvec": {
		"prefix": "printvec",
		"body": [
			"for (int i = 0; i < ${0:vec}.size(); i++) {\r",
			"    cout << ${0:vec}[i] << \" \";\r",
			"}\r",
			"cout << endl;"
		],
		"description": "Print Vector"
	},
	"mpit": {
		"prefix": "forit",
		"body": [
			"for (auto it = ${1:mp}.begin(); it != ${1:mp}.end(); it++) {\r",
			"    ${2://code}\r",
			"}"
		],
		"description": "For-iterator template for a map"
	},
	"getnextchar": {
		"prefix": "getnextchar",
		"body": [
			"inline char getNextChar(char ch, int offset = 0) {\r",
			"    int change = ((int)(ch - 'a')+1+offset)%26;\r",
			"    return (char)(change + 'a');\r",
			"}"
		],
		"description": "Simple inline function to get the next character with optional offset"
	},
	"reversegcd": {
		"prefix": "reversegcd",
		"body": [
			"pair<ll,pair<ll,ll> > reverseGCD(ll a, ll b) {\r",
			"\t// returns (g,(x,y))\r",
			"    pair<ll,pair<ll,ll>> ret;\r",
			"\tif (a==0) {\r",
			"\t\tret.first = b;\r",
			"\t\tret.second.first = 0;\r",
			"\t\tret.second.second = 1;\r",
			"\t} else {\r",
			"\t\tll g, x, y;\r",
			"\t\tpair<ll,pair<ll,ll>> temp = reverseGCD(b%a, a);\r",
			"\t\tg = temp.first;\r",
			"\t\tx = temp.second.first;\r",
			"\t\ty = temp.second.second;\r",
			"\t\tret.first = g;\r",
			"\t\tret.second.first = y - (b/a)*x;\r",
			"\t\tret.second.second = x;\r",
			"\t}\r",
			"\treturn ret;\r",
			"}\r",
			"\r",
			"ll modinv(ll den, ll m) {\r",
			"\tpair<ll,pair<ll,ll> > ans = reverseGCD(den, m) ;\r",
			"\tif (ans.first == 1) return (ans.second.first + m) % m;\r",
			"}\r",
			"\r",
			"// den and m must be coprime\r",
			"ll moddiv(ll num, ll den, ll m) {\r",
			"\treturn (num * modinv(den,m) ) % m;\r",
			"}"
		],
		"description": "Reverse Euclidean Algorithm"
	},
	"matrixexpo": {
		"prefix": "matrixexpo",
		"body": [
			"#define MX vector<vector<T>>\r",
			"#define MOD 1000000007\r",
			"\r",
			"template<typename T>\r",
			"class Matrix { // Only for NxN matrix\r",
			"public:\r",
			"    MX m;\r",
			"    int n;\r",
			"    Matrix(int n) {\r",
			"        this->n = n;\r",
			"        m.resize(n, vector<T>(n, 0));\r",
			"    }\r",
			"\r",
			"    Matrix(const MX &copy) {\r",
			"        this->m = MX(copy);\r",
			"        this->n = copy.size();\r",
			"    }\r",
			"\r",
			"    void print() const {\r",
			"        for (int i = 0; i < m.size(); i++) {\r",
			"            for (int j = 0; j < m[i].size(); j++) {\r",
			"                cout << m[i][j] << \" \";\r",
			"            }\r",
			"\r",
			"            cout << \"\\n\";\r",
			"        }\r",
			"        cout << flush;\r",
			"    }\r",
			"\r",
			"    Matrix operator*(const Matrix &b) const {\r",
			"        Matrix<T> result(n);\r",
			"        for (int i = 0; i < n; i++) {\r",
			"            for (int j = 0; j < n; j++) {\r",
			"                for (int k = 0; k < n; k++) {\r",
			"                    result.m[i][j] = (result.m[i][j] + (this->m[i][k] * b.m[k][j]) % MOD) % MOD;\r",
			"                }\r",
			"            }\r",
			"        }\r",
			"\r",
			"        return result;\r",
			"    }\r",
			"\r",
			"    Matrix binary(long long power) const {\r",
			"        Matrix<T> a(this->m);\r",
			"        Matrix<T> result(n);\r",
			"        for (int i = 0; i < n; i++) result.m[i][i] = 1;\r",
			"\r",
			"        while (power > 0) {\r",
			"            if (power % 2 == 1) {\r",
			"                result = result * a;\r",
			"                power--;\r",
			"            }\r",
			"\r",
			"            a = a * a;\r",
			"            power /= 2;\r",
			"        }\r",
			"\r",
			"        return result;\r",
			"    }\r",
			"};"
		],
		"description": "Matrix Class"
	},
	"intersects": {
		"prefix": "intersects",
		"body": [
			"inline bool intersects(int left, int right, int newLeft, int newRight) {\r",
			"    if (right >= newLeft && right <= newRight) return true;\r",
			"    if (left <= newRight && left >= newLeft) return true;\r",
			"    return false;\r",
			"}"
		],
		"description": "Inline bool function for intersection"
	},
	"defll": {
		"prefix": "defll",
		"body": "#define ll long long",
		"description": "define long long as ll"
	},
	"isvalid": {
		"prefix": "isvalid",
		"body": [
			"inline bool valid(int x, int y, int w, int h) {\r",
			"    return (x >= 0 && x < w && y >= 0 && y < h);\r",
			"}"
		],
		"description": "inline bool function that checks if a coordinate is valid"
	},
	"dxdy8": {
		"prefix": "dxdy8",
		"body": [
			"const int dx[8] = { 0, 0, -1, 1, 1, -1, 1, -1 };\r",
			"const int dy[8] = { -1, 1, 0, 0, 1, -1, -1, 1 };"
		],
		"description": "dx, dy arrays"
	},
	"dxdy4": {
		"prefix": "dxdy4",
		"body": [
			"const int dx[4] = { 0, 0, -1, 1 };\r",
			"const int dy[4] = { -1, 1, 0, 0 };"
		],
		"description": "dx, dy arrays"
	},
	"rotatemat": {
		"prefix": "rotatemat",
		"body": [
			"template<typename T>\r",
			"vector<vector<T>> rotate(const vector<vector<T>>& matrix, int x, int y) {\r",
			"    vector<vector<T>> result(x, vector<T>(y, 0));\r",
			"\r",
			"    int newColumn, newRow = 0;\r",
			"    for (int oldColumn = x - 1; oldColumn >= 0; oldColumn--) {\r",
			"        newColumn = 0;\r",
			"        for (int oldRow = 0; oldRow < y; oldRow++) {\r",
			"            result[newRow][newColumn] = matrix[oldRow][oldColumn];\r",
			"            newColumn++;\r",
			"        }\r",
			"        newRow++;\r",
			"    }\r",
			"\r",
			"    return result;\r",
			"}"
		],
		"description": "Rotate a Matrix - template function"
	},
	"flipnnh": {
		"prefix": "flipnnh",
		"body": [
			"template<typename T>\r",
			"vector<vector<T>> flipH(const vector<vector<T>> &matrix, int n) {\r",
			"    vector<vector<T>> result(n, vector<T>(n, 0));\r",
			"\r",
			"    for (int i = 0; i < n; i++) {\r",
			"        for (int j = 0; j < n; j++) {\r",
			"            result[i][j] = matrix[i][n-j-1];\r",
			"        }\r",
			"    }\r",
			"\r",
			"    return result;\r",
			"}"
		],
		"description": "Flip a NxN matrix horizontally - Template Function"
	},
	"flipnnv": {
		"prefix": "flipnnv",
		"body": [
			"template<typename T>\r",
			"vector<vector<T>> flipV(const vector<vector<T>> &matrix, int n) {\r",
			"    vector<vector<T>> result(n, vector<T>(n, 0));\r",
			"\r",
			"    for (int i = 0; i < n; i++) {\r",
			"        for (int j = 0; j < n; j++) {\r",
			"            result[i][j] = matrix[n-i-1][j];\r",
			"        }\r",
			"    }\r",
			"\r",
			"    return result;\r",
			"}"
		],
		"description": "Flip NxN matrix vertically - Template Function"
	},
	"chinese": {
		"prefix": "chinese",
		"body": [
			"template<typename T>\r",
			"T CRT(vector<T> n, vector<T> a) {\r",
			"    // n divisor, a is the remainder\r",
			"\r",
			"    T Wi = n[0], remainder = a[0];\r",
			"    int k = n.size();\r",
			"\r",
			"    for (int i = 1; i < k; ++i) {\r",
			"        T wi = n[i];\r",
			"        T bi = a[i];\r",
			"        auto rGCD = reverseGCD(Wi,wi);\r",
			"        T x = rGCD.second.first, y = rGCD.second.second;\r",
			"\r",
			"        T c = bi - remainder;\r",
			"\r",
			"        if (c % rGCD.first) // indicates that no result\r",
			"            return LLONG_MAX;\r",
			"\r",
			"        T W = wi / rGCD.first;\r",
			"        remainder += Wi*(((c/rGCD.first*x)%W+W)%W);\r",
			"        Wi *= W;\r",
			"    }\r",
			"\r",
			"    // represents the remainder of all zeros\r",
			"    if (!remainder) {\r",
			"        remainder = 1;\r",
			"        for(int i=0;i<k;++i)\r",
			"            remainder = remainder * n[i] / gcd(remainder, n[i]);\r",
			"    }\r",
			"\r",
			"    return remainder;\r",
			"}"
		],
		"description": "Chinese Remainder Theorem works with noncoprime moduli"
	},
	"eraseone": {
		"prefix": "eraseone",
		"body": [
			"inline void eraseOne(multiset<int> &s, int value) {\r",
			"    auto itr = s.find(value);\r",
			"    if (itr != s.end()){\r",
			"        s.erase(itr);\r",
			"    }\r",
			"}"
		],
		"description": "Erases only one occurence in a multiset"
	},
	"binexpo": {
		"prefix": "binexpo",
		"body": [
			"long long binary(long long base, long long power) {\r",
			"    long long result = 1;\r",
			"\r",
			"    while (power > 0) {\r",
			"        if (power % 2 == 1) {\r",
			"            result = result * base;\r",
			"            power--;\r",
			"        }\r",
			"\r",
			"        base = base * base;\r",
			"        power /= 2;\r",
			"    }\r",
			"\r",
			"    return result;\r",
			"}"
		],
		"description": "Binary Expo"
	},
	"compression": {
		"prefix": "compression",
		"body": [
			"// index compression\r",
			"int maxElement = INT_MIN;\r",
			"sort(comp.begin(), comp.end());\r",
			"for (int i = 0; i < n; i++) {\r",
			"    a[i] = lower_bound(comp.begin(), comp.end(), a[i]) - comp.begin() + 1;\r",
			"    if (a[i] > maxElement) maxElement = a[i];\r",
			"}"
		],
		"description": "Index Compression"
	},
	"fentree": {
		"prefix": "fentree",
		"body": [
			"struct FenwickTree {\r",
			"    vector<long long> fwt;\r",
			"\r",
			"    FenwickTree(int n) {\r",
			"        fwt.resize(n, 0);\r",
			"    }\r",
			"\r",
			"    void addFWT(int ind, long long val = 1) {\r",
			"        for (ind++; ind < fwt.size(); ind+=ind&-ind)\r",
			"            fwt[ind]+=val;\r",
			"    }\r",
			"\r",
			"    long long getFWT(int ind) {\r",
			"        long long s = 0;\r",
			"        for (ind++; ind > 0; ind-=ind&-ind)\r",
			"            s += fwt[ind];\r",
			"        return s;\r",
			"    }\r",
			"};"
		],
		"description": "Fenwick Tree"
	},
	"dsu": {
		"prefix": "dsu",
		"body": [
			"struct dsu {\r",
			"    vector<int> parent;\r",
			"\r",
			"    dsu(int n) {\r",
			"        parent.resize(n, -1);\r",
			"    }\r",
			"\r",
			"    int find_set(int a) {\r",
			"        if (parent[a] < 0) return a;\r",
			"        return parent[a] = find_set(parent[a]);\r",
			"    }\r",
			"\r",
			"    int merge(int a, int b) {\r",
			"        int x = find_set(a), y = find_set(b);\r",
			"        if (x == y) return x;\r",
			"        if (-parent[x] < -parent[y]) swap(x, y);\r",
			"        parent[x] += parent[y];\r",
			"        parent[y] = x;\r",
			"        return x;\r",
			"    }\r",
			"\r",
			"    bool are_same(int a, int b) {\r",
			"        return find_set(a) == find_set(b);\r",
			"    }\r",
			"\r",
			"    int size(int a) {\r",
			"        return -parent[find_set(a)];\r",
			"    }\r",
			"};"
		],
		"description": "dsu"
	},
	"lca": {
		"prefix": "lca",
		"body": [
			"struct LCA {\r",
			"    int n, l;\r",
			"    vector<vector<int>> adj;\r",
			"\r",
			"    int timer;\r",
			"    vector<int> tin, tout;\r",
			"    vector<vector<int>> up;\r",
			"\r",
			"    LCA(vector<vector<int>> adj, int root) {\r",
			"        this->n = adj.size();\r",
			"        this->adj = adj;\r",
			"        preprocess(root);\r",
			"    }\r",
			"\r",
			"    ~LCA() {\r",
			"        tin.clear();\r",
			"        tout.clear();\r",
			"        up.clear();\r",
			"        adj.clear();\r",
			"    }\r",
			"\r",
			"    void dfs(int v, int p) {\r",
			"        tin[v] = ++timer;\r",
			"        up[v][0] = p;\r",
			"        for (int i = 1; i <= l; ++i)\r",
			"            up[v][i] = up[up[v][i-1]][i-1];\r",
			"\r",
			"        for (int u : adj[v]) {\r",
			"            if (u != p)\r",
			"                dfs(u, v);\r",
			"        }\r",
			"\r",
			"        tout[v] = ++timer;\r",
			"    }\r",
			"\r",
			"    bool is_ancestor(int u, int v) {\r",
			"        return tin[u] <= tin[v] && tout[u] >= tout[v];\r",
			"    }\r",
			"\r",
			"    int lca(int u, int v) {\r",
			"        if (is_ancestor(u, v))\r",
			"            return u;\r",
			"        if (is_ancestor(v, u))\r",
			"            return v;\r",
			"        for (int i = l; i >= 0; --i) {\r",
			"            if (!is_ancestor(up[u][i], v))\r",
			"                u = up[u][i];\r",
			"        }\r",
			"        return up[u][0];\r",
			"    }\r",
			"\r",
			"    void preprocess(int root) {\r",
			"        tin.resize(n);\r",
			"        tout.resize(n);\r",
			"        timer = 0;\r",
			"        l = ceil(log2(n));\r",
			"        up.assign(n, vector<int>(l + 1));\r",
			"        dfs(root, root);\r",
			"    }\r",
			"};"
		],
		"description": "LCA"
	},
	"fft": {
		"prefix": "fft",
		"body": [
			"typedef long long ll;",
			"typedef complex<double> cd;",
			"",
			"const ll Max = 1e6+10;",
			"ll bound, logBound;",
			"const double pi = 4*atan(1.0);",
			"cd root[Max], arrA[Max], arrB[Max];",
			"ll perm[Max];",
			"ll prod[Max];",
			"",
			"void fft(cd* arr) {",
			"    for(ll i = 0; i < bound; i++) {",
			"        if(i < perm[i]) {",
			"            swap(arr[i], arr[perm[i]]);",
			"        }",
			"    }",
			"    for(ll len = 1; len < bound; len *= 2) {",
			"        for(ll pos = 0; pos < bound; pos += 2 * len) {",
			"            for(ll i = 0; i < len; i++) {",
			"                cd x = arr[pos + i], y = arr[pos + i + len] * root[bound / len / 2 * i];",
			"                arr[pos + i] = x + y;",
			"                arr[pos + i + len] = x - y;",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"void preCalc() {",
			"    ll hb = -1;",
			"    root[0] = 1;",
			"    double angle = 2 * pi / bound;",
			"    for(ll i = 1; i < bound; i++) {",
			"        if((i & (i - 1)) == 0) hb++;",
			"        root[i] = cd(cos(angle * i), sin(angle * i));",
			"        perm[i] = perm[i ^ (1 << hb)] + (1 << (logBound - hb - 1));",
			"    }",
			"}",
			"",
			"void mult(vector<ll> &a, vector<ll> &b, vector<ll> &c) {",
			"    logBound = 0;",
			"    while((1<<logBound) < a.size() || (1<<logBound) < b.size()) logBound++;",
			"    logBound++;",
			"    bound = (1<<logBound);",
			"    preCalc();",
			"    for(ll i = 0; i < a.size(); i++) {",
			"        arrA[i] = cd(a[i], 0);",
			"    }",
			"    for(ll i = a.size(); i < bound; i++) {",
			"        arrA[i] = cd(0, 0);",
			"    }",
			"    for(ll i = 0; i < b.size(); i++) {",
			"        arrB[i] = cd(b[i], 0);",
			"    }",
			"    for(ll i = b.size(); i < bound; i++) {",
			"        arrB[i] = cd(0, 0);",
			"    }",
			"    fft(arrA);",
			"    fft(arrB);",
			"    for(ll i = 0; i < bound; i++) {",
			"        arrA[i] *= arrB[i];",
			"    }",
			"    fft(arrA);",
			"    reverse(arrA + 1, arrA + bound);",
			"    c.resize(bound);",
			"    for(ll i = 0; i < bound; i++) {",
			"        arrA[i] /= bound;",
			"        ll temp = (arrA[i].real() > 0 ? arrA[i].real()+.5 : arrA[i].real() - .5);",
			"        c[i] = temp;",
			"    }",
			"    while(c.size() && c.back() == 0) c.pop_back();",
			"}"
		],
		"description": "FFT"
	},
	"segtree": {
		"prefix": "segtree",
		"body": [
			"struct SegmentTree {\r",
			"    const static int pw = 1 << 19;\r",
			"    const static ll def = 0;\r",
			"    int N = pw;\r",
			"\r",
			"    struct Node {\r",
			"        ll value = def;\r",
			"        Node operator+(const Node &other) {\r",
			"            return { this->value + other.value };\r",
			"        }\r",
			"    };\r",
			"\r",
			"    vector<Node> seg;\r",
			"    SegmentTree(int N) { this->N = N; seg.resize(2 * pw); }\r",
			"\r",
			"    void put(int i, Node v, int ind = 0, int l = 0, int r = -1) {\r",
			"        if (r == -1) r = N;\r",
			"        if (r - l == 1) { seg[ind] = v; return; }\r",
			"        int m = (l + r) / 2;\r",
			"        if (i < m) put(i, v, ind * 2 + 1, l, m);\r",
			"        else put(i, v, ind * 2 + 2, m, r);\r",
			"        seg[ind] = seg[ind * 2 + 1] + seg[ind * 2 + 2];\r",
			"    }\r",
			"\r",
			"    Node ask(int i, int ind = 0, int l = 0, int r = -1) {\r",
			"        if (r == -1) r = N;\r",
			"        if (i + 1 >= r) return seg[ind];\r",
			"        if (i < l) return { };\r",
			"        int m = (l + r) / 2;\r",
			"        return ask(i, ind * 2 + 1, l, m) + ask(i, ind * 2 + 2, m, r);\r",
			"    }\r",
			"    // result in [b,e) of node that covers [l,r)\r",
			"    Node askLR(int b, int e, int ind = 0, int l = 0, int r = -1) {\r",
			"        if (r == -1) r = N;\r",
			"        if (l>=e || r<=b) return { };\r",
			"        if (l>=b && r<=e) return seg[ind];\r",
			"        int m = (l + r) / 2;\r",
			"        return askLR(b, e, ind * 2 + 1, l, m) + askLR(b, e, ind * 2 + 2, m, r);\r",
			"    }\r",
			"};\r",
			""
		],
		"description": "Light Segment Tree"
	},
	"moquery": {
		"prefix": "moquery",
		"body": [
			"struct Query {",
			"    int id;",
			"    int l, r;",
			"",
			"    bool operator<(const Query &rhs) const {",
			"        if (l / magic == rhs.l / magic) return r < rhs.r;",
			"        return (l / magic < rhs.l / magic);",
			"    }",
			"};"
		],
		"description": "Mo's Algorithm Query Structure"
	},
	"moalgo": {
		"prefix": "moalgo",
		"body": [
			"vector<int> ans_vec(q);",
			"    int cur_l = 0, cur_r = -1;",
			"    for (int i = 0; i < q; i++) {",
			"        while (cur_l > queries[i].l) {",
			"            cur_l--;",
			"            add(cur_l);",
			"        }",
			"",
			"        while (cur_r < queries[i].r) {",
			"            cur_r++;",
			"            add(cur_r);",
			"        }",
			"",
			"        while (cur_l < queries[i].l) {",
			"            remove(cur_l);",
			"            cur_l++;",
			"        }",
			"",
			"        while (cur_r > queries[i].r) {",
			"            remove(cur_r);",
			"            cur_r--;",
			"        }",
			"",
			"        ans_vec[queries[i].id] = ans;",
			"    }"
		],
		"description": "Mo's Algorithm"
	},
	"hasher": {
		"prefix": "hasher",
		"body": [
			"struct VectorHasher {\r",
			"    int operator()(const vector<int> &V) const {\r",
			"        int hash = V.size();\r",
			"        for(auto &i : V) {\r",
			"            hash ^= i + 0x9e3779b9 + (hash << 6) + (hash >> 2);\r",
			"        }\r",
			"        return hash;\r",
			"    }\r",
			"};"
		],
		"description": "Vector Hasher"
	},
	"tpoint": {
		"prefix": "tpoint",
		"body": [
			"template<class T>",
			"struct Point {",
			"\ttypedef Point P;",
			"\tT x, y;",
			"\texplicit Point(T x=0, T y=0) : x(x), y(y) {}",
			"\tbool operator<(P p) const { return tie(x,y) < tie(p.x,p.y); }",
			"\tbool operator==(P p) const { return tie(x,y)==tie(p.x,p.y); }",
			"\tP operator+(P p) const { return P(x+p.x, y+p.y); }",
			"\tP operator-(P p) const { return P(x-p.x, y-p.y); }",
			"\tP operator*(T d) const { return P(x*d, y*d); }",
			"\tP operator/(T d) const { return P(x/d, y/d); }",
			"\tT dot(P p) const { return x*p.x + y*p.y; }",
			"\tT cross(P p) const { return x*p.y - y*p.x; }",
			"\tT cross(P a, P b) const { return (a-*this).cross(b-*this); }",
			"\tT dist2() const { return x*x + y*y; }",
			"\tdouble dist() const { return sqrt((double)dist2()); }",
			"\t// angle to x-axis in interval [-pi, pi]",
			"\tdouble angle() const { return atan2(y, x); }",
			"\tP unit() const { return *this/dist(); } // makes dist()=1",
			"\tP perp() const { return P(-y, x); } // rotates +90 degrees",
			"\tP normal() const { return perp().unit(); }",
			"\t// returns point rotated 'a' radians ccw around the origin",
			"\tP rotate(double a) const {",
			"\t\treturn P(x*cos(a)-y*sin(a),x*sin(a)+y*cos(a)); }",
			"\tfriend ostream& operator<<(ostream& os, P p) {",
			"\t\treturn os << \"(\" << p.x << \",\" << p.y << \")\"; }",
			"    void GCD() {",
			"        int GCD = gcd(x, y);",
			"        x /= GCD; y /= GCD;",
			"    }",
			"};"
		],
		"description": "Point Class"
	},
	"binsearch": {
		"prefix": "binsearch",
		"body": [
			"#define ll long long",
			"// [start,end)",
			"ll binary_search(function<bool(ll)> func, ll start, ll end) {",
			"    /* func:int ->bool",
			"        returns smallest int x where func(x) evaluates to true, searches in [start,end), it is assumed the values are false, .. , false, true ...",
			"    */",
			"",
			"    if (end <= start) return end;   // has to be here, otherwise func(end-1) in next line could be a problem",
			"    if (!func(end-1)) return end;",
			"    while (end - start > 1) {",
			"        ll mid = (start + end) / 2;",
			"        if (func(mid)) end = mid; else start = mid;",
			"    }",
			"",
			"    return (func(start) ? start : end);",
			"};"
		],
		"description": "Binary Search Snippet"
	},
	"codejam": {
		"prefix": "codejam",
		"body": [
			"#include <bits/stdc++.h>",
			"#define ll long long",
			"#define endl '\\n'",
			"",
			"using namespace std;",
			"",
			"void testCase() {",
			"",
			"}",
			"",
			"int main() {",
			"    int t;",
			"    cin >> t;",
			"",
			"    for (int tt = 0; tt < t; tt++) {",
			"        cout << \"Case #\" << tt + 1 << \":\" << endl;",
			"        testCase();",
			"    }",
			"",
			"    cout << flush;",
			"    return 0;",
			"}"
		],
		"description": "CodeJam Template"
	},
	"rollback": {
		"prefix": "rollback",
		"body": [
			"struct dsu_save {",
			"    int u, v, parent_u, parent_v;",
			"};",
			"",
			"struct dsu {",
			"    vector<int> parent;",
			"    vector<dsu_save> saves;",
			"",
			"    dsu(int n) {",
			"        parent.resize(n, -1);",
			"        saves.reserve(n);",
			"    }",
			"",
			"    int find_set(int a) {",
			"        if (parent[a] < 0) return a;",
			"        return find_set(parent[a]);",
			"    }",
			"",
			"    bool merge(int a, int b, bool save = false) {",
			"        int x = find_set(a), y = find_set(b);",
			"        if (x == y) return false;",
			"        if (-parent[x] < -parent[y]) swap(x, y);",
			"        if (save) saves.push_back({ x, y, parent[x], parent[y] });",
			"        parent[x] += parent[y];",
			"        parent[y] = x;",
			"        return save;",
			"    }",
			"",
			"    void rollback() {",
			"        if (saves.empty()) return;",
			"        dsu_save top = saves.back();",
			"        saves.pop_back();",
			"        parent[top.u] = top.parent_u;",
			"        parent[top.v] = top.parent_v;",
			"    }",
			"",
			"    bool are_same(int a, int b) {",
			"        return find_set(a) == find_set(b);",
			"    }",
			"",
			"    int size(int a) {",
			"        return -parent[find_set(a)];",
			"    }",
			"};"
		],
		"description": "DSU with Rollbacks"
	},
	"modint": {
		"prefix": "modint",
		"body": [
			"const int mod=998244353;",
			"struct mi {",
			"    int v;",
			"    mi(){v=0;}",
			"    mi(ll _v){v=int(-mod<=_v&&_v<mod?_v:_v%mod); if(v<0)v+=mod;}",
			"    explicit operator int()const{return v;}",
			"    friend bool operator==(const mi &a,const mi &b){return (a.v==b.v);}",
			"    friend bool operator!=(const mi &a,const mi &b){return (a.v!=b.v);}",
			"    friend bool operator<(const mi &a,const mi &b){return (a.v<b.v);}",
			"    mi& operator+=(const mi &m){if((v+=m.v)>=mod)v-=mod; return *this;}",
			"    mi& operator-=(const mi &m){if((v-=m.v)<0)v+=mod; return *this;}",
			"    mi& operator*=(const mi &m){v=((ll)(v)*m.v)%mod; return *this;}",
			"    mi& operator/=(const mi &m){return (*this)*=inv(m);}",
			"    friend mi pow(mi a,ll e){mi r=1; for(;e;a*=a,e/=2)if(e&1)r*=a; return r;}",
			"    friend mi inv(mi a){return pow(a,mod-2);}",
			"    mi operator-()const{return mi(-v);}",
			"    mi& operator++(){return (*this)+=1;}",
			"    mi& operator--(){return (*this)-=1;}",
			"    friend mi operator++(mi &a,int){mi t=a; ++a; return t;}",
			"    friend mi operator--(mi &a,int){mi t=a; --a; return t;}",
			"    friend mi operator+(mi a,const mi &b){return a+=b;}",
			"    friend mi operator-(mi a,const mi &b){return a-=b;}",
			"    friend mi operator*(mi a,const mi &b){return a*=b;}",
			"    friend mi operator/(mi a,const mi &b){return a/=b;}",
			"    friend istream& operator>>(istream &is,mi &m){ll _v; is >> _v; m=mi(_v); return is;}",
			"    friend ostream& operator<<(ostream &os,const mi &m){os << m.v; return os;}",
			"};"
		],
		"description": "Modular Arithmetic Integer Struct"
	},
	"ntt": {
		"prefix": "ntt",
		"body": [
			"void ntt(vector<mi> &a)",
			"{",
			"    int n=a.size(),L=31-__builtin_clz(n);",
			"    vector<int> rev(n);",
			"    for(int i=0;i<n;i++) rev[i]=(rev[i/2]+((i&1)<<L))/2;",
			"    for(int i=0;i<n;i++) if(i<rev[i]) swap(a[i],a[rev[i]]);",
			"    static vector<mi> rt(2,1);",
			"    for(static int k=2,s=2;k<n;k*=2,s++)",
			"    {",
			"        rt.resize(n);",
			"        mi z=pow(mi(primitive_root),mod>>s);",
			"        for(int i=k;i<2*k;i++) rt[i]=rt[i/2]*((i&1)?z:1);",
			"    }",
			"    for(int k=1;k<n;k*=2)",
			"    {",
			"        for(int i=0;i<n;i+=2*k)",
			"        {",
			"            for(int j=0;j<k;j++)",
			"            {",
			"                mi z=rt[j+k]*a[i+j+k];",
			"                a[i+j+k]=a[i+j]-z;",
			"                a[i+j]+=z;",
			"            }",
			"        }",
			"    }",
			"}",
			"",
			"vector<mi> conv(vector<mi> &a,vector<mi> &b)",
			"{",
			"    int sa=a.size(),sb=b.size();",
			"    if(sa==0||sb==0) return {};",
			"    int n=1<<(32-__builtin_clz(sa+sb-2));",
			"    mi inv=1/mi(n);",
			"    vector<mi> f(a),g(b),h(n);",
			"    f.resize(n); g.resize(n);",
			"    ntt(f); ntt(g);",
			"    for(int i=0;i<n;i++) h[(-i)&(n-1)]=(f[i]*g[i]*inv);",
			"    ntt(h);",
			"    h.resize(sa+sb-1);",
			"    return h;",
			"}",
			"",
			"vector<mi> multipoly(vector<vector<mi>> v)",
			"{",
			"    auto cmp=[&](const vector<mi> &a,const vector<mi> &b){return (a.size()>b.size());};",
			"    priority_queue<vector<mi>,vector<vector<mi>>,decltype(cmp)> q(cmp);",
			"    for(auto &u:v) q.push(u);",
			"    while(q.size()>=2)",
			"    {",
			"        auto a=q.top();",
			"        q.pop();",
			"        auto b=q.top();",
			"        q.pop();",
			"        q.push(conv(a,b));",
			"    }",
			"    return q.top();",
			"}"
		],
		"description": "Numeric Theoretic Transform"
	},
	"minrotation": {
		"prefix": "minrotation",
		"body": [
			"int minRotation(vector<int> s) {",
			"\tint a=0, N=s.size(); extend(s, s);",
			"\trep(b,0,N) rep(k,0,N) {",
			"        if (a+k == b || s[a+k] < s[b+k]) {b += max(0, k-1); break;}",
			"        if (s[a+k] > s[b+k]) { a = b; break; }",
			"    }",
			"\treturn a;",
			"}"
		],
		"description": "Minimum Lex String Rotation"
	},
	"extend": {
		"prefix": "extend",
		"body": [
			"void extend(vector<int>& a, const vector<int>& b) {",
			"    a.reserve((int)a.size() + b.size());",
			"    int size = b.size();",
			"    for (int i = 0; i < size; i++) a.push_back(b[i]);",
			"}"
		]
	},
	"bigint": {
		"prefix": "bigint",
		"body": [
			"const int base = 1000000000;",
			"const int base_digits = 9; ",
			"struct bigint {",
			"\tvector<int> a;",
			"\tint sign;",
			"\t/*<arpa>*/",
			"\tint size(){",
			"\t\tif(a.empty())return 0;",
			"\t\tint ans=(a.size()-1)*base_digits;",
			"\t\tint ca=a.back();",
			"\t\twhile(ca)",
			"\t\t\tans++,ca/=10;",
			"\t\treturn ans;",
			"\t}",
			"\tbigint operator ^(const bigint &v){",
			"\t\tbigint ans=1,a=*this,b=v;",
			"\t\twhile(!b.isZero()){",
			"\t\t\tif(b%2)",
			"\t\t\t\tans*=a;",
			"\t\t\ta*=a,b/=2;",
			"\t\t}",
			"\t\treturn ans;",
			"\t}",
			"\tstring to_string(){",
			"\t\tstringstream ss;",
			"\t\tss << *this;",
			"\t\tstring s;",
			"\t\tss >> s;",
			"\t\treturn s;",
			"\t}",
			"\tint sumof(){",
			"\t\tstring s = to_string();",
			"\t\tint ans = 0;",
			"\t\tfor(auto c : s)  ans += c - '0';",
			"\t\treturn ans;",
			"\t}",
			"\t/*</arpa>*/",
			"\tbigint() :",
			"\t\tsign(1) {",
			"\t}",
			"",
			"\tbigint(long long v) {",
			"\t\t*this = v;",
			"\t}",
			"",
			"\tbigint(const string &s) {",
			"\t\tread(s);",
			"\t}",
			"",
			"\tvoid operator=(const bigint &v) {",
			"\t\tsign = v.sign;",
			"\t\ta = v.a;",
			"\t}",
			"",
			"\tvoid operator=(long long v) {",
			"\t\tsign = 1;",
			"\t\ta.clear();",
			"\t\tif (v < 0)",
			"\t\t\tsign = -1, v = -v;",
			"\t\tfor (; v > 0; v = v / base)",
			"\t\t\ta.push_back(v % base);",
			"\t}",
			"",
			"\tbigint operator+(const bigint &v) const {",
			"\t\tif (sign == v.sign) {",
			"\t\t\tbigint res = v;",
			"",
			"\t\t\tfor (int i = 0, carry = 0; i < (int) max(a.size(), v.a.size()) || carry; ++i) {",
			"\t\t\t\tif (i == (int) res.a.size())",
			"\t\t\t\t\tres.a.push_back(0);",
			"\t\t\t\tres.a[i] += carry + (i < (int) a.size() ? a[i] : 0);",
			"\t\t\t\tcarry = res.a[i] >= base;",
			"\t\t\t\tif (carry)",
			"\t\t\t\t\tres.a[i] -= base;",
			"\t\t\t}",
			"\t\t\treturn res;",
			"\t\t}",
			"\t\treturn *this - (-v);",
			"\t}",
			"",
			"\tbigint operator-(const bigint &v) const {",
			"\t\tif (sign == v.sign) {",
			"\t\t\tif (abs() >= v.abs()) {",
			"\t\t\t\tbigint res = *this;",
			"\t\t\t\tfor (int i = 0, carry = 0; i < (int) v.a.size() || carry; ++i) {",
			"\t\t\t\t\tres.a[i] -= carry + (i < (int) v.a.size() ? v.a[i] : 0);",
			"\t\t\t\t\tcarry = res.a[i] < 0;",
			"\t\t\t\t\tif (carry)",
			"\t\t\t\t\t\tres.a[i] += base;",
			"\t\t\t\t}",
			"\t\t\t\tres.trim();",
			"\t\t\t\treturn res;",
			"\t\t\t}",
			"\t\t\treturn -(v - *this);",
			"\t\t}",
			"\t\treturn *this + (-v);",
			"\t}",
			"",
			"\tvoid operator*=(int v) {",
			"\t\tif (v < 0)",
			"\t\t\tsign = -sign, v = -v;",
			"\t\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
			"\t\t\tif (i == (int) a.size())",
			"\t\t\t\ta.push_back(0);",
			"\t\t\tlong long cur = a[i] * (long long) v + carry;",
			"\t\t\tcarry = (int) (cur / base);",
			"\t\t\ta[i] = (int) (cur % base);",
			"\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
			"\t\t}",
			"\t\ttrim();",
			"\t}",
			"",
			"\tbigint operator*(int v) const {",
			"\t\tbigint res = *this;",
			"\t\tres *= v;",
			"\t\treturn res;",
			"\t}",
			"",
			"\tvoid operator*=(long long v) {",
			"\t\tif (v < 0)",
			"\t\t\tsign = -sign, v = -v;",
			"\t\tif(v > base){",
			"\t\t\t*this = *this * (v / base) * base + *this * (v % base);",
			"\t\t\treturn ;",
			"\t\t}",
			"\t\tfor (int i = 0, carry = 0; i < (int) a.size() || carry; ++i) {",
			"\t\t\tif (i == (int) a.size())",
			"\t\t\t\ta.push_back(0);",
			"\t\t\tlong long cur = a[i] * (long long) v + carry;",
			"\t\t\tcarry = (int) (cur / base);",
			"\t\t\ta[i] = (int) (cur % base);",
			"\t\t\t//asm(\"divl %%ecx\" : \"=a\"(carry), \"=d\"(a[i]) : \"A\"(cur), \"c\"(base));",
			"\t\t}",
			"\t\ttrim();",
			"\t}",
			"",
			"\tbigint operator*(long long v) const {",
			"\t\tbigint res = *this;",
			"\t\tres *= v;",
			"\t\treturn res;",
			"\t}",
			"",
			"\tfriend pair<bigint, bigint> divmod(const bigint &a1, const bigint &b1) {",
			"\t\tint norm = base / (b1.a.back() + 1);",
			"\t\tbigint a = a1.abs() * norm;",
			"\t\tbigint b = b1.abs() * norm;",
			"\t\tbigint q, r;",
			"\t\tq.a.resize(a.a.size());",
			"",
			"\t\tfor (int i = a.a.size() - 1; i >= 0; i--) {",
			"\t\t\tr *= base;",
			"\t\t\tr += a.a[i];",
			"\t\t\tint s1 = r.a.size() <= b.a.size() ? 0 : r.a[b.a.size()];",
			"\t\t\tint s2 = r.a.size() <= b.a.size() - 1 ? 0 : r.a[b.a.size() - 1];",
			"\t\t\tint d = ((long long) base * s1 + s2) / b.a.back();",
			"\t\t\tr -= b * d;",
			"\t\t\twhile (r < 0)",
			"\t\t\t\tr += b, --d;",
			"\t\t\tq.a[i] = d;",
			"\t\t}",
			"",
			"\t\tq.sign = a1.sign * b1.sign;",
			"\t\tr.sign = a1.sign;",
			"\t\tq.trim();",
			"\t\tr.trim();",
			"\t\treturn make_pair(q, r / norm);",
			"\t}",
			"",
			"\tbigint operator/(const bigint &v) const {",
			"\t\treturn divmod(*this, v).first;",
			"\t}",
			"",
			"\tbigint operator%(const bigint &v) const {",
			"\t\treturn divmod(*this, v).second;",
			"\t}",
			"",
			"\tvoid operator/=(int v) {",
			"\t\tif (v < 0)",
			"\t\t\tsign = -sign, v = -v;",
			"\t\tfor (int i = (int) a.size() - 1, rem = 0; i >= 0; --i) {",
			"\t\t\tlong long cur = a[i] + rem * (long long) base;",
			"\t\t\ta[i] = (int) (cur / v);",
			"\t\t\trem = (int) (cur % v);",
			"\t\t}",
			"\t\ttrim();",
			"\t}",
			"",
			"\tbigint operator/(int v) const {",
			"\t\tbigint res = *this;",
			"\t\tres /= v;",
			"\t\treturn res;",
			"\t}",
			"",
			"\tint operator%(int v) const {",
			"\t\tif (v < 0)",
			"\t\t\tv = -v;",
			"\t\tint m = 0;",
			"\t\tfor (int i = a.size() - 1; i >= 0; --i)",
			"\t\t\tm = (a[i] + m * (long long) base) % v;",
			"\t\treturn m * sign;",
			"\t}",
			"",
			"\tvoid operator+=(const bigint &v) {",
			"\t\t*this = *this + v;",
			"\t}",
			"\tvoid operator-=(const bigint &v) {",
			"\t\t*this = *this - v;",
			"\t}",
			"\tvoid operator*=(const bigint &v) {",
			"\t\t*this = *this * v;",
			"\t}",
			"\tvoid operator/=(const bigint &v) {",
			"\t\t*this = *this / v;",
			"\t}",
			"",
			"\tbool operator<(const bigint &v) const {",
			"\t\tif (sign != v.sign)",
			"\t\t\treturn sign < v.sign;",
			"\t\tif (a.size() != v.a.size())",
			"\t\t\treturn a.size() * sign < v.a.size() * v.sign;",
			"\t\tfor (int i = a.size() - 1; i >= 0; i--)",
			"\t\t\tif (a[i] != v.a[i])",
			"\t\t\t\treturn a[i] * sign < v.a[i] * sign;",
			"\t\treturn false;",
			"\t}",
			"",
			"\tbool operator>(const bigint &v) const {",
			"\t\treturn v < *this;",
			"\t}",
			"\tbool operator<=(const bigint &v) const {",
			"\t\treturn !(v < *this);",
			"\t}",
			"\tbool operator>=(const bigint &v) const {",
			"\t\treturn !(*this < v);",
			"\t}",
			"\tbool operator==(const bigint &v) const {",
			"\t\treturn !(*this < v) && !(v < *this);",
			"\t}",
			"\tbool operator!=(const bigint &v) const {",
			"\t\treturn *this < v || v < *this;",
			"\t}",
			"",
			"\tvoid trim() {",
			"\t\twhile (!a.empty() && !a.back())",
			"\t\t\ta.pop_back();",
			"\t\tif (a.empty())",
			"\t\t\tsign = 1;",
			"\t}",
			"",
			"\tbool isZero() const {",
			"\t\treturn a.empty() || (a.size() == 1 && !a[0]);",
			"\t}",
			"",
			"\tbigint operator-() const {",
			"\t\tbigint res = *this;",
			"\t\tres.sign = -sign;",
			"\t\treturn res;",
			"\t}",
			"",
			"\tbigint abs() const {",
			"\t\tbigint res = *this;",
			"\t\tres.sign *= res.sign;",
			"\t\treturn res;",
			"\t}",
			"",
			"\tlong long longValue() const {",
			"\t\tlong long res = 0;",
			"\t\tfor (int i = a.size() - 1; i >= 0; i--)",
			"\t\t\tres = res * base + a[i];",
			"\t\treturn res * sign;",
			"\t}",
			"",
			"\tfriend bigint gcd(const bigint &a, const bigint &b) {",
			"\t\treturn b.isZero() ? a : gcd(b, a % b);",
			"\t}",
			"\tfriend bigint lcm(const bigint &a, const bigint &b) {",
			"\t\treturn a / gcd(a, b) * b;",
			"\t}",
			"",
			"\tvoid read(const string &s) {",
			"\t\tsign = 1;",
			"\t\ta.clear();",
			"\t\tint pos = 0;",
			"\t\twhile (pos < (int) s.size() && (s[pos] == '-' || s[pos] == '+')) {",
			"\t\t\tif (s[pos] == '-')",
			"\t\t\t\tsign = -sign;",
			"\t\t\t++pos;",
			"\t\t}",
			"\t\tfor (int i = s.size() - 1; i >= pos; i -= base_digits) {",
			"\t\t\tint x = 0;",
			"\t\t\tfor (int j = max(pos, i - base_digits + 1); j <= i; j++)",
			"\t\t\t\tx = x * 10 + s[j] - '0';",
			"\t\t\ta.push_back(x);",
			"\t\t}",
			"\t\ttrim();",
			"\t}",
			"",
			"\tfriend istream& operator>>(istream &stream, bigint &v) {",
			"\t\tstring s;",
			"\t\tstream >> s;",
			"\t\tv.read(s);",
			"\t\treturn stream;",
			"\t}",
			"",
			"\tfriend ostream& operator<<(ostream &stream, const bigint &v) {",
			"\t\tif (v.sign == -1)",
			"\t\t\tstream << '-';",
			"\t\tstream << (v.a.empty() ? 0 : v.a.back());",
			"\t\tfor (int i = (int) v.a.size() - 2; i >= 0; --i)",
			"\t\t\tstream << setw(base_digits) << setfill('0') << v.a[i];",
			"\t\treturn stream;",
			"\t}",
			"",
			"\tstatic vector<int> convert_base(const vector<int> &a, int old_digits, int new_digits) {",
			"\t\tvector<long long> p(max(old_digits, new_digits) + 1);",
			"\t\tp[0] = 1;",
			"\t\tfor (int i = 1; i < (int) p.size(); i++)",
			"\t\t\tp[i] = p[i - 1] * 10;",
			"\t\tvector<int> res;",
			"\t\tlong long cur = 0;",
			"\t\tint cur_digits = 0;",
			"\t\tfor (int i = 0; i < (int) a.size(); i++) {",
			"\t\t\tcur += a[i] * p[cur_digits];",
			"\t\t\tcur_digits += old_digits;",
			"\t\t\twhile (cur_digits >= new_digits) {",
			"\t\t\t\tres.push_back(int(cur % p[new_digits]));",
			"\t\t\t\tcur /= p[new_digits];",
			"\t\t\t\tcur_digits -= new_digits;",
			"\t\t\t}",
			"\t\t}",
			"\t\tres.push_back((int) cur);",
			"\t\twhile (!res.empty() && !res.back())",
			"\t\t\tres.pop_back();",
			"\t\treturn res;",
			"\t}",
			"",
			"\ttypedef vector<long long> vll;",
			"",
			"\tstatic vll karatsubaMultiply(const vll &a, const vll &b) {",
			"\t\tint n = a.size();",
			"\t\tvll res(n + n);",
			"\t\tif (n <= 32) {",
			"\t\t\tfor (int i = 0; i < n; i++)",
			"\t\t\t\tfor (int j = 0; j < n; j++)",
			"\t\t\t\t\tres[i + j] += a[i] * b[j];",
			"\t\t\treturn res;",
			"\t\t}",
			"",
			"\t\tint k = n >> 1;",
			"\t\tvll a1(a.begin(), a.begin() + k);",
			"\t\tvll a2(a.begin() + k, a.end());",
			"\t\tvll b1(b.begin(), b.begin() + k);",
			"\t\tvll b2(b.begin() + k, b.end());",
			"",
			"\t\tvll a1b1 = karatsubaMultiply(a1, b1);",
			"\t\tvll a2b2 = karatsubaMultiply(a2, b2);",
			"",
			"\t\tfor (int i = 0; i < k; i++)",
			"\t\t\ta2[i] += a1[i];",
			"\t\tfor (int i = 0; i < k; i++)",
			"\t\t\tb2[i] += b1[i];",
			"",
			"\t\tvll r = karatsubaMultiply(a2, b2);",
			"\t\tfor (int i = 0; i < (int) a1b1.size(); i++)",
			"\t\t\tr[i] -= a1b1[i];",
			"\t\tfor (int i = 0; i < (int) a2b2.size(); i++)",
			"\t\t\tr[i] -= a2b2[i];",
			"",
			"\t\tfor (int i = 0; i < (int) r.size(); i++)",
			"\t\t\tres[i + k] += r[i];",
			"\t\tfor (int i = 0; i < (int) a1b1.size(); i++)",
			"\t\t\tres[i] += a1b1[i];",
			"\t\tfor (int i = 0; i < (int) a2b2.size(); i++)",
			"\t\t\tres[i + n] += a2b2[i];",
			"\t\treturn res;",
			"\t}",
			"",
			"\tbigint operator*(const bigint &v) const {",
			"\t\tvector<int> a6 = convert_base(this->a, base_digits, 6);",
			"\t\tvector<int> b6 = convert_base(v.a, base_digits, 6);",
			"\t\tvll a(a6.begin(), a6.end());",
			"\t\tvll b(b6.begin(), b6.end());",
			"\t\twhile (a.size() < b.size())",
			"\t\t\ta.push_back(0);",
			"\t\twhile (b.size() < a.size())",
			"\t\t\tb.push_back(0);",
			"\t\twhile (a.size() & (a.size() - 1))",
			"\t\t\ta.push_back(0), b.push_back(0);",
			"\t\tvll c = karatsubaMultiply(a, b);",
			"\t\tbigint res;",
			"\t\tres.sign = sign * v.sign;",
			"\t\tfor (int i = 0, carry = 0; i < (int) c.size(); i++) {",
			"\t\t\tlong long cur = c[i] + carry;",
			"\t\t\tres.a.push_back((int) (cur % 1000000));",
			"\t\t\tcarry = (int) (cur / 1000000);",
			"\t\t}",
			"\t\tres.a = convert_base(res.a, 6, base_digits);",
			"\t\tres.trim();",
			"\t\treturn res;",
			"\t}",
			"};"
		],
		"description": "Big Integer Struct"
	}
}